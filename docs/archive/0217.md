# 1

macos 上，只是有了初始满屏高度，但是宽度为 0 了，这不对。宽度不需要满屏，按照原来的宽度即可。

# 2


设置页，单击下载繁体中文资源包，出现错误日志：
[17/Feb/2026 23:22:12] GET /api/packs HTTP/1.1
[17/Feb/2026 23:22:12] 404
[17/Feb/2026 23:22:12] GET /server/packs/lang_cht.zip.gz HTTP/1.1

flutter: ❌ Download error: Exception: Download failed: 404

关于 size
按照《人机交互指南》，在 macos 上，标准工具/阅读器	1000 px	800 px	接近 5:4，稳重感强
在手机上，满屏即可。


# 3

你在朗读真人语音的时候，是不是没有使用时间戳数据？见assets/audio_timestamps.json

刚才我测试，TTS 语音没有问题，我可以单击或拖动节进度块控制播放位置。但切换到真人语音（两个语音都是，普通和高级）后，就无法通过单击或拖动节进度块控制播放位置了。可以单击，节的高这有变化；可以拖拽，但无法控制播放位置。

# 4

![alt text](assets/e1cf1277a0f89578e8ae68ebf5586451.png)

图示，简体数据库中有不少这种无法识别的字符：�
请全部找出来

# 5

当前问题：Android Rust TTS 深度集成及声线列表为空故障
1. 已完成的工作（基石已打通）
JNI 通讯验证：通过 
initRustTts
 返回的心跳字符串 "Rust Engine v1.0 Alive"，确证 Rust 动态库在 Android 端已成功加载且双向通讯正常。
NDK 上下文注入：已在 
lib.rs
 中使用 ndk-context 注册了 Flutter 的 ApplicationContext，解决了原生 Native 代码获取 Android 系统服务的权限隔离问题。
绝对路径透传机制：为解决 Android 资产无法从 Native 直接访问的问题，实现了 Flutter 侧提取 
bible_lexicon_chs.json
 到本地 support 目录，并将该绝对路径透传给 Rust 的全局变量 ASSETS_PATH。
Java Bridge 实现：创建了 rs.tts.Bridge 类（继承自 UtteranceProgressListener 并实现 OnInitListener），以满足 Rust 
tts
 crate 在 Android 后端所需的 JNI 回调入口。
构建环境锁定：将环境固定为 Android SDK/API 36 (Android 16 Preview) 和 NDK 28，解决了之前的 SIMD 指令集编译冲突。
2. 当前核心阻碍（待解决）
现象：尽管底层 JNI 联通，但在 Android 运行环境下，Rust 层的 
r_get_voices
 依然返回 0 个声线，且调用 
r_speak
 保持沉默（无报错但无声）。
怀疑方向：
JNI 签名冲突：rs.tts.Bridge 中的 native 方法签名与 
tts
 crate 内部预期的签名可能存在微小差异（如包名、参数类型），导致 Java 侧的回调无法正确触发 Rust 侧的函数。
ClassLoader 隔离：Rust 
tts
 crate 在工作线程尝试查找 Java 端的 rs/tts/Bridge 类时，由于 ClassLoader 环境不同，可能导致类加载失败，进而导致后端引擎初始化中途退回。
初始化时序问题：TextToSpeech.OnInitListener 尚未回调成功，用户便已尝试获取声线列表。
3. 建议新会话的下一步行动
高优先级：通过 adb logcat 重点排查包含 JNI 或 NoSuchMethodError 的异常，确认 rs.tts.Bridge 是否成功绑定。
代码修正：检查 rs.tts.Bridge 类的包名是否与 
tts
 crate 源码中的 hardcode 包名严格匹配。
逻辑优化：在 
process_tts_text
 中添加更多针对 Android 路径读取的 log::debug 信息，确证词典文件已成功读取并解析。